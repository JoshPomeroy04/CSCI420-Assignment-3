{
    "R1": "#include <stdlib.h>\n\n\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\n\nvoid deleteNode(struct Node **head, int key) {\n    struct Node *temp = *head;\n    struct Node *prev = NULL;\n\n\n    // Case 1: The head node itself holds the key\n    if (temp != NULL && temp->data == key) {\n        *head = temp->next;  // Move head to next node\n        free(temp);          // Free old head\n        return;\n    }\n\n\n    // Case 2: Search for the key\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n\n    // If key was not present in the list\n    if (temp == NULL) return;\n\n\n    // Unlink the node from the list\n    prev->next = temp->next;\n    free(temp);\n}",
    "R2": "#include <stdlib.h>\n\n\nstruct Node {\n    int data;\n    struct Node *next;\n};\n\n\nvoid deleteNode(struct Node **head, int key) {\n    struct Node *temp = *head;\n    struct Node *prev = NULL;\n\n\n    // Case 1: Head node holds the key\n    if (temp != NULL && temp->data == key) {\n        *head = temp->next;  // Move head to the next node\n        free(temp);          // Free old head\n        return;\n    }\n\n\n    // Case 2: Traverse the list to find the key\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n\n    // If key is not found, do nothing\n    if (temp == NULL) return;\n\n\n    // Unlink the node and free memory\n    prev->next = temp->next;\n    free(temp);\n}"
}